import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.TreeMap;

public class MiniBasicModel {
    private Map<Integer, String> code = new TreeMap<>();
    private Map<String, Double> variables = new HashMap<>();
    private int currentLine;

    public MiniBasicModel() {
    }

    /**
     * Loads the program from a file.
     * Each line should begin with the line number followed by the command.
     *
     * @param file The file containing the MiniBasic program.
     * @throws IOException If there is an error reading the file.
     */
    public void loadProgram(File file) throws IOException {
        BufferedReader reader = new BufferedReader(new FileReader(file));

        String line;
        while ((line = reader.readLine()) != null) {
            line = line.trim();
            if (!line.isEmpty()) {
                int spaceIndex = line.indexOf(" ");
                int lineNumber = Integer.parseInt(line.substring(0, spaceIndex));
                String command = line.substring(spaceIndex + 1);
                code.put(lineNumber, command);
            }
        }

        reader.close();
    }

    /**
     * Executes the loaded MiniBasic program.
     * It processes 'print', 'if', 'goto', and variable assignments.
     *
     * @return The output generated by the 'print' statements.
     */
    public String executeProgram() {
        StringBuilder output = new StringBuilder();
        currentLine = (Integer) code.keySet().iterator().next();

        while (code.containsKey(currentLine)) {
            String command = code.get(currentLine);
            String[] parts;

            if (command.startsWith("print")) {
                String variable = command.split(" ")[1];
                output.append(String.format("%.2f\n", variables.getOrDefault(variable, 0.0)));
            } else if (command.contains("=")) {
                parts = command.split("=");
                String variable = parts[0].trim();
                double value = evaluateExpression(parts[1].trim());
                variables.put(variable, value);
            } else if (command.startsWith("goto")) {
                currentLine = Integer.parseInt(command.split(" ")[1]);
                continue;
            } else if (command.startsWith("if")) {
                parts = command.substring(command.indexOf("(") + 1, command.indexOf(")")).split("=");
                String variable = parts[0].trim();
                double value = Double.parseDouble(parts[1].trim());
                if (variables.getOrDefault(variable, 0.0) == value) {
                    currentLine = Integer.parseInt(command.split("goto")[1].trim());
                    continue;
                }
            } else if (command.equals("end")) {
                break;
            }

            // Move to the next line number
            currentLine = getNextLineNumber(currentLine);
        }

        return output.toString();
    }

    /**
     * Evaluates the expression on the right-hand side of a variable assignment.
     * It handles numbers and variables.
     *
     * @param expression The expression to evaluate.
     * @return The evaluated result of the expression.
     */
    private double evaluateExpression(String expression) {
        String[] parts = expression.split(" ");
        double result;
        
        // Check if the first part is a variable
        boolean isVariable = Character.isAlphabetic(parts[0].charAt(0));
        if (isVariable) {
            result = variables.getOrDefault(parts[0], 0.0);
        } else {
            result = Double.parseDouble(parts[0]);
        }

        // Process the rest of the expression (if any)
        for (int i = 1; i < parts.length; i += 2) {
            String operator = parts[i];
            double operand;
            if (Character.isAlphabetic(parts[i + 1].charAt(0))) {
                operand = variables.getOrDefault(parts[i + 1], 0.0);
            } else {
                operand = Double.parseDouble(parts[i + 1]);
            }

            // Apply the operator
            switch (operator) {
                case "+":
                    result += operand;
                    break;
                case "-":
                    result -= operand;
                    break;
                case "*":
                    result *= operand;
                    break;
                case "/":
                    result /= operand;
                    break;
            }
        }

        return result;
    }

    /**
     * Finds the next line number after the given one.
     * 
     * @param lineNumber The current line number.
     * @return The next line number, or -1 if none exists.
     */
    private int getNextLineNumber(int lineNumber) {
        Iterator<Integer> iterator = code.keySet().iterator();

        Integer nextLine;
        do {
            if (!iterator.hasNext()) {
                return -1;
            }
            nextLine = iterator.next();
        } while (nextLine <= lineNumber);

        return nextLine;
    }
}

